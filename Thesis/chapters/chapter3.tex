\chapter{Smalltalk-80}\label{cha:chapter3}
In this chapter a description of the Smalltalk-80 ecosystem will be given. 
Unless stated otherwise, the main source of information is the language specification by Goldberg and Robson, also referred to as the \enquote{Bluebook} because of its blue cover \cite{bluebook1983}.

Fundamentally Smalltalk-80 is an purely object orientated programming language, meaning that even primitive types such as numbers are represented by an object. 
As usual with object orientation, inheritance is also possible.
While this is certainly correct, narrowing the language down to object orientation is also partly misleading. 
A big aspect of the design of Smalltalk-80 revolves around message passing. 
When calling a procedure (a method or function in the terminology of Smalltalk-80), a message is sent to the class of the object the procedure is affecting, this is called the \enquote{receiver}.
The receiver then looks up the corresponding functionality within its memory context or, if applicable, in the context of its parent class.
After a successful lookup and execution of the procedure, the result will be passed back to the caller, the so called \enquote{sender}. 

To illustrate this fundamental concept of sender, receiver and message passing consider the simple task of calculating the sum of 3 and 4. 
The example is taken directly from Wolczko \cite{Wolczko1984}.

In the syntax of Smalltalk-80, this is simply written as \stcode{3+4}.
This is to be read from left to right, so on the number object \stcode{3} the \enquote{selector} \stcode{+} is invoked with the argument of the number object \stcode{4}.
So the current context, the one which actually wants to get the result, sends a message with the selector \stcode{+} (standing for arithmetic addition) to the underlying class object for the receiver, in this case the number object \stcode{3}. 
The selector \stcode{+} also takes one argument, which in this case is a reference to the object \stcode{4}. 

To illustrate the following explanation further, see \Cref{fig:illust3+4}. The boxes in this figure represent the boundaries of a context, the arrows indicate direct or implicit communication between contexts.

When receiving the message (A), the object \stcode{3} looks up the selector in its class definition (B). 
The definition defines a second argument \stcode{aNumber}, the second number for the addition. The implicit call (C) fetches the reference of this argument (D) and forwards it to the context of \stcode{3} (E).
Now the object \stcode{3} performs the defined procedure (in this case the arithmetic addition of 3 and 4). 
As a result of this addition, a reference to the number object \stcode{7} is created (F) and returned to the calling context, the sender (G). 

\image[h]{\textwidth}{illust3+4}{Illustration of the context switching and message passing of the procedure \stcode{3+4}}{illust3+4}

The virtual machine operates like a classic stack machine. Each context has it's own stack. When switching contexts, the receivers stack is initialized with a reference to the sender. Instructions push and pop values to and from the active stack, store values in memory or are used to trigger the transmission of a message between contexts. 

\section{Structure of Instructions}
In total the Smalltalk-80 virtual machine recognizes 248 bytecode encodings. These bytecodes are encoded within one byte and numbered 0 through 255 with 8 encodings being left unused. 
While this amount of bytecodes seems rather high, these are actually only 29 real instructions. 

The vast majority of instructions utilizes parts of its bytecode for the argument to the instruction. For example the instruction to push a constant to the stack is only specified by the 3 highest bits in the form of \texttt{001}. The remaining 5 bits are used to encode the constant number that should be pushed to the stack. 

Alternatively there are also instructions which are encoded utilizing the full 8 bit. These instructions take one or two complete bytes as input. In these cases the virtual machine just treats the following bytes as arguments to the instruction. 

Lastly there are 3 long jump instructions (160 to 175) which apply both of these encodings.

\Cref{fig:st-bytecodes} shows a table of all Smalltalk-80 instructions, their bytecode ranges and their encoding patterns.The table is taken directly from the language specification.

\image[h]{\textwidth}{st-bytecodes}{Encoding table for the Smalltalk-80 bytecodes}{st-bytecodes}

For the purpose of this thesis, we can simplify the categorization of these instructions into 4 groups: 
\begin{itemize}
  \item Stack bytecodes: These instructions directly modify the stack. 
  \item Return bytecodes: These instructions are used to return from one context to the sender, they are mostly used to return the result from a message. 
  \item Send bytecodes: The inverse of the return bytecodes, they send a message to a receivers selector.
  \item Jump bytecodes: This groups together the 5 explicit jump instructions.
\end{itemize}

Of these, the last 3 types are especially relevant for the implementation of a Just-in-time compiler. 
This is because the return, send and jump instructions all result in a context switch, which in turn constitutes the end of a basic block.

\section{Implementation of the interpreter}
Beside the language specification the bluebook also describes the implementation details for a conforming Smalltalk-80 interpreter. 
The described interpreter works, as one would expect. First all necessary variables are initialized and the existing saved memory is read from the image file.
Following this, the interpretation loop is executed. The next instructions are looked up based on the instruction pointer, the method pointer and active context as shown in \Cref{fig:context}.
\todo{figure for the context pointer stuff}
After fetching the next instruction byte, the functionality of the instruction is looked up (the bluebook calls this stage \enquote{dispatching}) and the corresponding functionality is executed.
