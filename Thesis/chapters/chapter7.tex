\chapter{Future Work}\label{cha:futurework}
Due to the shortcomings in this project explained above, there is a lot of work to be still done in the future. 

The first, and most important aspect to look at is to understand and properly document the memory mappings of either, or both, of the used implementations. The Bluebook intentionally left out this aspect as it is hugely dependent on the machine hosting the virtual machine, which in turn results in a lot of differing implementations. Regrettably, the memory models of these implementations are mostly glanced over when describing the interpreter and are just provided as is. The implementation of a \jit{} compiler requires a deeper understanding of how the memory works, otherwise, it is nearly impossible to implement in a performant manner. 

Next, the translation and execution of the machine code must be determined. The provided prototype assembly code is just the beginning. It is only one of the 27 base instructions of Smalltalk-80 and the assembly code is never actually translated to bytecode nor executed. I imagine correctly reading and writing back the values to the stack address could result in problems. Additionally one has to be careful about utilizing registers for the necessary calculations which already contain values from running the interpreter. 

Finally, while it seems natural that the \jit{} compiler should come with a performance improvement, this needs to be tested and verified. For this purpose, one could utilize the internal self-tests of the Smalltalk-80 image. The repository for Keller's interpreter contains a folder called \texttt{benchmark}, in it Keller describes how to use the previously mentioned self-testing functions defined in the image. This script measures the time from the start of the execution of each function to its completion and at the end sums the time (in milliseconds) and prints the sum at the end of completion. Additionally, it is probably required to remove the artificial restriction of cycles per second defined in both interpreters as these define an upper limit to the performance of the execution. 
