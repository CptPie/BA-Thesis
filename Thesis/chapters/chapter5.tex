\chapter{Implementation of a JIT compiler for Smalltalk-80}
In this chapter I will describe the design decisions and implementation details of this (partial) JIT-compiler implementation for Smalltalk-80.
\todo{more intro}
\section{Design}
The fundamental design aspects follow closely the general design for a Just-In-Time compiler outlined in \Cref{cha:jit}.
Since both of the used interpreter implementations follow the description provided by the Bluebook, both the interpreter and the changes to facilitate just-in-time compilation are very similar. 

To recap the high-level structure again. Utilizing the interpretation cycle of the baseline implementations, every time a instruction is executed, the instruction is added alongside some metadata to the currently active basic block. If the instruction is considered to be of a type that produces a jump in the program flow, the basic block is ended and a new basic block is created. This relationship between instructions and basic blocks is illustrated in \Cref{fig:basicblock-1}. \todo{figure, see whiteboard}

When creating a new basic block, the location of the next instruction, so the target of the jump in the program flow, is used as an unique identifier for the basic block. 
If a jump to an existing basic block is detected, its heat value is incremented by one and no instructions are added to the block. 
Once a block hits the configured heat threshold value, it is compiled to machine bytecode. In contrary, if a basic block has not been executed for a certain amount of cycles, the heat value gets decremented. This resolves the issue of unnecessarily compiling rarely executed basic blocks. 
Following the management of the heat value, the compilation of the basic block is initiated.

The actual translation of the instruction to machine bytecode is a rather manual process. There are two ways to do this translation, either by translating the logic of an instruction directly into machine bytecode or by going through an intermediate language. For this project it was chosen to go with the intermediate language approach, namely reimplementing the logic using the riscv64 assembly language. For the translation between the assembly and the bytecode the library keystone (\url{https://www.keystone-engine.org/}) is used.

After translating the interpreter loop continues as before with one exception. When a basic block, which has already been translated to bytecode is entered, instead of entering either the interpretation or the compilation steps, the program instead jumps directly to the previously generated bytecode and executes it. All the variables effected need to be read from and written back to the memory directly to notifiy the interpreter of any changes.

\section{New classes and data structures}
For the managment of information necessary for the compilation process several new classes and data structures were defined independently of the existing codebase. This modular approach already proved vital during the project when switching from one interpreter implementation to the other. A brief summary of the purpose of each of these additions along with the reasoning behind certain aspects will be given in this section.

\subsection{The JIT class}
On startup, variables necessary for the functionality of the interpreter are initialized by calling a function. Since this function is only executed once, on startup, this is also well suited to setup the necessary variables for the JIT compiler. 
For this a new class, called JIT, was created. The purpose of this class is to bundle all functionalities related to the JIT process in itself and provide scoping for the variables used. It's constructor is used to do the aforementioned initialization of variables. The only configurable variable for the JIT-compiler is the heat threshold, that is how often a basic block has to be executed to be eligible for compilation. This value is passed to the class by the constructor.
This class keeps track of all identified basic blocks, the configured heat level as well as the basic block that contains the currently interpreted instruction.
Since this class manages the majority of the logic for the JIT-compiler, most newly created functions are members of this class. 

\subsection{The location structure}
As explained before in \Cref{cha:smalltalk}, the interpreted language does not really have a concept of files. Every piece of sourcecode is kept in memory, separated by contexts. 
To keep track of a position within the program, the Location structure was created. This structure saves the currently active context, the method context and the instruction pointer within those.

\subsection{The Instruction structure}
The purpose of this structure is to represent a single instruction in the program. Every instructions contains information about where in the program flow it is located, its location value as well as the bytecode it represents and a human readable name for the instruction to ease debugging.

\subsection{The BasicBlock structure}
To manage the basic blocks properly, this structure got introduced.
The primary purpose of the basic block is to keep a list of instructions within it, as well as the blocks heat value and its start and end locations. 
The instruction list is necessary for the translation to machine bytecode as every instruction is translated individually. After translating the instruction, the resulting bytecode will get added to the basic blocks bytecode variable for later use. 
Keeping track of the beginning of a basic block is necessary since this information is used to find the correct basic block to jump to, or if none exist, to create a new basic block.

\section{Dbaney's smalltalk interpreter}
\subsection{Structure and Design}
\subsection{Changes to the interpreter}
\subsection{Encountered Problems}


\section{Keller's smalltalk interpreter}
\subsection{Structure and Design}
\subsection{Changes to the interpreter}
\subsection{Encountered Problems}


